/* Note: Exponential ElGamal only supports plaintexts constrained to 40 bits, 
because solving the Discrete Log is needed during decryption
It is the responsiblity of the smart contract developer to ensure 
that all plaintexts are in the u40 range before encryption
*/
use dep::std::ec::tecurve::affine::Curve as AffineCurve;
use dep::std::ec::tecurve::affine::Point as Gaffine;
use dep::std::collections::vec::Vec;
use dep::std;
use dep::bjj;

/* Code of the circuit used at each transfer of the token to prove the validity of transfer (sender 
has enough balance) and correctness of encrypted new balances of sender and receiver.
To be sure this is not vulnerable, we added a check in the smart contract to make sure that sender
is different from receiver (a nonce variable is not needed in our case because transfers are 
initiated by from=msg.sender in the contract, so replay attack is impossible)
*/
// This proof can be generated by anyone
// randomness will be known by processor, but the input amount is already public
// so no info is leaked
fn main(
    randomness: Field, // randomness used for encryption, amount is already public so doesnt matter
    // Public inputs, this can be executed by anyone
    packed_public_key: pub [Field;32],
    amount_sum: pub u40,
    old_enc_balance_1: pub Gaffine,
    old_enc_balance_2: pub Gaffine,
    new_enc_balance_1: pub Gaffine,
    new_enc_balance_2: pub Gaffine
) {
    let bjj_affine = bjj::get_affine_curve();
    let mut packed_public_key_u8: [u8;32] = [0; 32];

    // for some reason nargo 0.17 and 0.18 is not able to verify the circuit without this type conversion
    for i in 0..32 {
        packed_public_key_u8[i] = packed_public_key[i] as u8;
    }
    let public_key = bjj::unpack_point(packed_public_key_u8);
    let mut encrypted_amount = bjj::exp_elgamal_encrypt(public_key, amount_sum, randomness);

    // addition of the points on Baby Jubjub : this operation is additevely homomorphic for Exponential ElGamal
    let balance_new_to_encrypted_computed = (
        bjj_affine.add(old_enc_balance_1, encrypted_amount.0), bjj_affine.add(old_enc_balance_2, encrypted_amount.1)
    );

    // checks that the new encrypted balance of receiver is correct
    assert(
        (balance_new_to_encrypted_computed.0.x == new_enc_balance_1.x)
        & (balance_new_to_encrypted_computed.0.y == new_enc_balance_1.y)
        & (balance_new_to_encrypted_computed.1.x == new_enc_balance_2.x)
        & (balance_new_to_encrypted_computed.1.y == new_enc_balance_2.y)
    );
}

// Because of a bug in Noir 10.3, this test will cause a stack overflow error, but you can check that it passes via `nargo prove` instead of `nargo test`: the values inside Prover.toml are strictly equivalent to this test
#[test]
fn test_process_deposit() {
    let private_key: Field = 0x0510bae26a9b59ebad67a4324c944b1910a778e8481d7f08ddba6bcd2b94b2c4;

    // see debug notebook for an example on how to compute those
    let randomness: Field = 168986485046885582825082387270879151100288537211746581237924789162159767775;

    // see debug notebook for an example on how to compute those
    let public_key: Gaffine = bjj::priv_to_pub_key(private_key);
    let packed_public_key = bjj::pack_point(public_key);
    let mut packed_public_key_Field: [Field;32] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for i in 0..32 {
        packed_public_key_Field[i] = packed_public_key[i] as Field;
    }
    let old_balance_clear = 0 as u40;
    let amount = 999 as u40;
    let old_balance_enc : (Gaffine,Gaffine) = bjj::exp_elgamal_encrypt(public_key, old_balance_clear, randomness);
    let encrypted_amount = bjj::exp_elgamal_encrypt(public_key, amount, randomness);
    let bjj_affine = bjj::get_affine_curve();
    let new_balance_enc = (
        bjj_affine.add(old_balance_enc.0, encrypted_amount.0), bjj_affine.add(old_balance_enc.1, encrypted_amount.1)
    );

    let bjj_affine = bjj::get_affine_curve();
    let base_pt = bjj::get_base_point();
    let embedded_balance = bjj_affine.mul((old_balance_clear + amount) as Field, base_pt);
    let decoded_value = bjj::exp_elgamal_decrypt(private_key, new_balance_enc);
    assert(decoded_value.x == embedded_balance.x);
    assert(decoded_value.y == embedded_balance.y);

    std::println(amount);
    std::println(old_balance_enc.0);
    std::println(old_balance_enc.1);
    std::println(new_balance_enc.0);
    std::println(new_balance_enc.1);

    main(
        randomness,
        packed_public_key_Field,
        amount,
        old_balance_enc.0,
        old_balance_enc.1,
        new_balance_enc.0,
        new_balance_enc.1
    );
}
